// src/services/staff.js
import { v4 as uuidv4 } from "uuid";
import { pool } from "../utils/db.js";
import bcrypt from "bcrypt";
import { readGlobalShiftTime } from "../services/shifts.js";
// src/services/staff.js
import { uploadToDrive } from "../middleware/driveUpload.js"; // your Drive helper

// Upload multiple staff documents
async function uploadStaffDocuments(staffId, files) {
  if (!files || !files.length) return [];

  const uploadedFileIds = [];
  for (const file of files) {
    const fileId = await uploadToDrive(file.buffer, file.originalname, file.mimetype);
    uploadedFileIds.push(fileId);
  }

  // Append uploaded documents to existing ones
  const { rows } = await pool.query(
    "UPDATE staff SET documents = COALESCE(documents, '{}') || $1 WHERE id=$2 RETURNING documents",
    [uploadedFileIds, staffId]
  );

  return rows[0].documents;
}

// Fetch staff documents
async function getStaffDocuments(staffId) {
  const { rows } = await pool.query("SELECT documents FROM staff WHERE id=$1", [staffId]);
  if (!rows.length) throw new Error("Staff not found");
  return rows[0].documents;
}

/* --------------------- helpers --------------------- */

// Matches "HH:mm" or "HH:mm:ss"
const timeRe = /^\d{2}:\d{2}(:\d{2})?$/;

// Convert "HH:mm" or "HH:mm:ss" to minutes since midnight
function toMinutes(t) {
  const [h, m] = t.split(":").map(Number);
  return h * 60 + (m ?? 0);
}

// Return true if staff shift fits inside global window
function isStaffWindowInsideGlobal(gStartMin, gEndMin, sStartMin, sEndMin) {
  if (sStartMin >= sEndMin) return false; // staff shift itself must be forward (no wrap)

  // Global normal (e.g., 09:00–17:00)
  if (gEndMin >= gStartMin) {
    return sStartMin >= gStartMin && sEndMin <= gEndMin;
  }

  // Global overnight (e.g., 22:00–06:00)
  const inLateSegment = sStartMin >= gStartMin && sEndMin <= 1440;
  const inEarlySegment = sStartMin >= 0 && sEndMin <= gEndMin;
  return inLateSegment || inEarlySegment;
}

// Read the configured global shift window (wraps the shared reader; returns { start, end })
async function readGlobalShiftTimes() {
  const { start, end } = await readGlobalShiftTime();
  return { start, end };
}

// Ensure staff shift sits inside the global window
async function assertStaffShiftWithinGlobal(shiftStart, shiftEnd) {
  if (!timeRe.test(shiftStart) || !timeRe.test(shiftEnd)) {
    throw new Error("shiftStart/shiftEnd must be in HH:mm or HH:mm:ss format");
  }

  const global = await readGlobalShiftTimes();
  const gStartMin = toMinutes(global.start);
  const gEndMin = toMinutes(global.end);
  const sStartMin = toMinutes(shiftStart);
  const sEndMin = toMinutes(shiftEnd);

  if (!isStaffWindowInsideGlobal(gStartMin, gEndMin, sStartMin, sEndMin)) {
    const gStartDisp = global.start.slice(0, 5);
    const gEndDisp = global.end.slice(0, 5);
    throw new Error(
      `Staff shift (${shiftStart}–${shiftEnd}) must be within global window ${gStartDisp}–${gEndDisp} (Toronto local time).`
    );
  }
}

/* --------------------- services --------------------- */

// POST /api/staff
async function createStaff(req, res) {
  const {
    userId,
    firstName,
    lastName,
    email,
    contactNo,
    emergencyContactNo,
    shiftStart,
    shiftEnd,
    // NEW:
    birthday,
    joiningDate,
    leaveTaken,
    totalLeaves,
    position,
    managerId,
    jobFamily,
  } = req.body;

  try {
    // shift validation (unchanged)
    if ((shiftStart && !shiftEnd) || (!shiftStart && shiftEnd)) {
      return res
        .status(400)
        .json({ error: "Provide both shiftStart and shiftEnd together." });
    }
    if (shiftStart && shiftEnd) {
      await assertStaffShiftWithinGlobal(shiftStart, shiftEnd);
    }

    // Validate managerId (if provided)
    if (managerId) {
      const { rowCount } = await pool.query(
        "SELECT 1 FROM staff WHERE id = $1",
        [managerId]
      );
      if (!rowCount) {
        return res
          .status(400)
          .json({ error: "managerId must be an existing staff id" });
      }
    }

    const id = uuidv4();
    // employee_id is generated by DB default; use RETURNING to get it
    const { rows } = await pool.query(
      `INSERT INTO staff (
         id, user_id, first_name, last_name, email, contact_no, emergency_contact_no,
         shift_start_local_time, shift_end_local_time,
         birthday, joining_date, leave_taken, total_leaves, position, manager_id, job_family
       )
       VALUES (
         $1,$2,$3,$4,$5,$6,$7,
         $8::time,$9::time,
         $10::date,$11::date,$12,$13,$14,$15,$16
       )
       RETURNING employee_id, birthday, joining_date, leave_taken, total_leaves, position, manager_id, job_family`,
      [
        id,
        userId,
        firstName,
        lastName,
        email,
        contactNo,
        emergencyContactNo,
        shiftStart ?? null,
        shiftEnd ?? null,
        birthday ?? null,
        joiningDate ?? null,
        leaveTaken ?? 0,
        totalLeaves ?? 0,
        position ?? null,
        managerId ?? null,
        jobFamily ?? null,
      ]
    );

    const ret = rows[0];

    res.status(201).json({
      id,
      userId,
      employeeId: ret.employee_id,
      firstName,
      lastName,
      email,
      contactNo,
      emergencyContactNo,
      shiftStart: shiftStart ?? null,
      shiftEnd: shiftEnd ?? null,
      birthday: ret.birthday,
      joiningDate: ret.joining_date,
      leaveTaken: ret.leave_taken,
      totalLeaves: ret.total_leaves,
      position: ret.position,
      managerId: ret.manager_id,
      jobFamily: ret.job_family,
    });
  } catch (err) {
    if (err.code === "23505") {
      return res
        .status(409)
        .json({ error: "Email or EmployeeID must be unique" });
    }
    console.error(err);
    res.status(500).json({ error: err.message || "Failed to create staff" });
  }
}

// GET /api/staff
async function listStaff(req, res) {
  try {
    const { rows } = await pool.query(
      "SELECT * FROM staff ORDER BY created_at DESC"
    );
    res.json(rows);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch staff" });
  }
}

// GET /api/staff/:id
async function getStaffById(req, res) {
  try {
    const { rows } = await pool.query("SELECT * FROM staff WHERE id=$1", [
      req.params.id,
    ]);
    if (!rows.length) return res.status(404).json({ error: "Not found" });
    res.json(rows[0]);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch staff" });
  }
}

// PATCH /api/staff/:id
async function updateStaff(req, res) {
  const updates = req.body;

  const wantsShiftStart = Object.prototype.hasOwnProperty.call(updates, "shiftStart");
  const wantsShiftEnd = Object.prototype.hasOwnProperty.call(updates, "shiftEnd");

  try {
    if ((wantsShiftStart && !wantsShiftEnd) || (!wantsShiftStart && wantsShiftEnd)) {
      return res.status(400).json({
        error: "When updating shift times, provide both shiftStart and shiftEnd together.",
      });
    }
    if (wantsShiftStart && wantsShiftEnd) {
      await assertStaffShiftWithinGlobal(updates.shiftStart, updates.shiftEnd);
    }

    // Validate managerId if present
    if (Object.prototype.hasOwnProperty.call(updates, "managerId")) {
      if (updates.managerId) {
        const { rowCount } = await pool.query("SELECT 1 FROM staff WHERE id=$1", [
          updates.managerId,
        ]);
        if (!rowCount) {
          return res.status(400).json({ error: "managerId must be an existing staff id" });
        }
        if (updates.managerId === req.params.id) {
          return res.status(400).json({ error: "A staff member cannot be their own manager" });
        }
      }
    }

    const columnMap = {
      firstName: "first_name",
      lastName: "last_name",
      email: "email",
      contactNo: "contact_no",
      emergencyContactNo: "emergency_contact_no",
      shiftStart: "shift_start_local_time",
      shiftEnd: "shift_end_local_time",
      // NEW:
      birthday: "birthday",
      joiningDate: "joining_date",
      leaveTaken: "leave_taken",
      totalLeaves: "total_leaves",
      position: "position",
      managerId: "manager_id",
      jobFamily: "job_family",
      // employeeId intentionally excluded
    };

    const fields = [];
    const params = [];
    let idx = 1;

    for (const [key, value] of Object.entries(updates)) {
      const col = columnMap[key];
      if (!col) continue;
      if (key === "shiftStart" || key === "shiftEnd") {
        fields.push(`${col}=$${idx++}::time`);
        params.push(value ?? null);
      } else if (key === "birthday" || key === "joiningDate") {
        fields.push(`${col}=$${idx++}::date`);
        params.push(value ?? null);
      } else {
        fields.push(`${col}=$${idx++}`);
        params.push(value);
      }
    }

    if (!fields.length) {
      return res.status(400).json({ error: "No valid fields to update" });
    }

    params.push(req.params.id);

    const { rowCount } = await pool.query(
      `UPDATE staff SET ${fields.join(", ")} WHERE id=$${idx}`,
      params
    );
    if (!rowCount) return res.status(404).json({ error: "Not found" });
    res.json({ ok: true });
  } catch (err) {
    if (err.code === "23505") return res.status(409).json({ error: "Email must be unique" });
    console.error(err);
    res.status(500).json({ error: err.message || "Failed to update staff" });
  }
}


// DELETE /api/staff/:id
async function deleteStaff(req, res) {
  try {
    const { rowCount } = await pool.query("DELETE FROM staff WHERE id=$1", [
      req.params.id,
    ]);
    if (!rowCount) return res.status(404).json({ error: "Not found" });
    res.json({ ok: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to delete staff" });
  }
}
/**
 * GET /api/staff/:id/allowed
 * Returns whether the staff's user is allowed
 */
async function getStaffAllowed(req, res) {
  const staffId = req.params.id;

  try {
    const { rows } = await pool.query(
      `
      SELECT u.allowed
      FROM staff s
      JOIN users u ON s.user_id = u.id
      WHERE s.id = $1
      `,
      [staffId]
    );

    if (!rows.length) {
      return res.status(404).json({ error: "Staff not found" });
    }

    res.json({ allowed: rows[0].allowed });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch allowed status" });
  }
}

async function getStaffBlocked(req, res) {
  const staffId = req.params.id;

  try {
    const { rows } = await pool.query(
      `
      SELECT u.is_blocked
      FROM staff s
      JOIN users u ON s.user_id = u.id
      WHERE s.id = $1
      `,
      [staffId]
    );

    if (!rows.length) {
      return res.status(404).json({ error: "Staff not found" });
    }

    res.json({ blocked: rows[0].is_blocked });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to fetch Bloced status" });
  }
}

export {
  createStaff,
  listStaff,
  getStaffAllowed,
  getStaffById,
  getStaffBlocked,
  updateStaff,
  deleteStaff,
  assertStaffShiftWithinGlobal,
  isStaffWindowInsideGlobal,
  getStaffDocuments,
  uploadStaffDocuments
};
